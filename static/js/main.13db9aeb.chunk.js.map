{"version":3,"sources":["utils/drawing.ts","components/image-uploader/ImageUploader.tsx","models/DoddleClassifier.model.ts","components/image-drawer/constants.ts","components/image-drawer/ImageDrawerTools.tsx","components/image-drawer/ImageDrawer.tsx","components/image-drawer/ImageDrawerDetector.tsx","App.tsx","reportWebVitals.ts","index.tsx"],"names":["drawRect","detections","ctx","forEach","prediction","bbox","x","y","width","height","score","Math","round","Number","EPSILON","text","class","color","floor","random","toString","strokeStyle","font","beginPath","fillStyle","fillText","rect","stroke","ImageUploader","props","image","Image","onload","canvasRef","current","getContext","drawImage","detect","onerror","console","error","useRef","a","cocoNet","detectedObjects","info","orientation","span","type","onChange","event","src","URL","createObjectURL","currentTarget","files","ref","displayName","DoddleClassifier","model","classes","tf","this","jsonClasses","canvasElement","getImageData","topN","imgData","getImageFromCanvas","startScope","tensor","fromPixels","resized","resizeBilinear","reshape","toFloat","normalized","sub","div","batched","expandDims","predict","predictTopN","endScope","data","argMax","Error","n","topValues","Array","from","sort","b","slice","map","indexOf","SKETCH_DEFAULT_EXPORT_FORMAT","SKETCH_DEFAULT_EXPORT_FILENAME","SKETCH_DEFAULT_CANVAS_COLOR","ImageDrawerTools","useState","isPenMode","setIsPenMode","sketchRef","exportImage","element","document","createElement","setAttribute","style","display","body","appendChild","click","removeChild","actions","buttonType","icon","UndoOutlined","onClick","undo","RedoOutlined","redo","EditOutlined","eraseMode","ClearOutlined","ReloadOutlined","isDanger","clearCanvas","DeleteOutlined","resetCanvas","DownloadOutlined","backgroundColor","borderColor","action","index","marginBottom","danger","title","strokeColor","onChangeComplete","setStrokeColor","hex","borderWidth","borderRadius","marginRight","verticalAlign","htmlFor","id","name","min","max","defaultValue","newStrokeWidth","setStrokeWidth","disabled","newEraseWidth","setEraseWidth","ImageDrawer","sketchCanvas","setSketchCanvas","strokeWidth","eraseWidth","gutter","node","border","eraserWidth","canvasColor","OBJECT_DETECTION_MODEL","Option","Select","ImageDrawerDetector","coco","setModel","setTopN","objectDetectionPredictions","setObjectDetectionPredictions","detectionCanvas","setDetectionCanvas","detectCoco","detectQuickDraw","doddleClassifier","result","quickDraw","value","Object","keys","key","bordered","dataSource","locale","emptyText","renderItem","item","Item","Text","strong","App","setDoddleClassifier","setCocoNet","loadModel","log","cocossd","useEffect","loadCoco","loadDoddleClassifier","subTitle","size","tip","indicator","fontSize","spin","position","zIndex","top","right","marginTop","paddingLeft","paddingRight","reportWebVitals","onPerfEntry","Function","then","getCLS","getFID","getFCP","getLCP","getTTFB","ReactDOM","render","StrictMode","getElementById"],"mappings":"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","file":"static/js/main.13db9aeb.chunk.js","sourcesContent":["import { DetectedObject } from \"@tensorflow-models/coco-ssd\";\n\nexport const drawRect = (detections: DetectedObject[], ctx: CanvasRenderingContext2D) =>{\n  // Loop through each prediction\n  detections.forEach(prediction => {\n    // Extract boxes and classes\n    const [x, y, width, height] = prediction.bbox;\n    const score = Math.round((prediction.score + Number.EPSILON) * 100) / 100;\n    const text = `Class: ${prediction.class} (${score})`;\n\n    // Set styling\n    const color = Math.floor(Math.random()*16777215).toString(16);\n    ctx.strokeStyle = '#' + color;\n    ctx.font = '18px Arial';\n\n    // Draw rectangles and text\n    ctx.beginPath();\n    ctx.fillStyle = '#' + color;\n    ctx.fillText(text, x, y);\n    ctx.rect(x, y, width, height);\n    ctx.stroke();\n  });\n}\n","import { useRef } from \"react\";\nimport { Input, Row, Col, Divider } from \"antd\";\nimport { ObjectDetection} from \"@tensorflow-models/coco-ssd\";\nimport { drawRect } from \"../../utils/drawing\";\n\ninterface ImageUploaderProps {\n  cocoNet: ObjectDetection;\n}\n\nfunction ImageUploader(props: ImageUploaderProps): JSX.Element {\n  const image = new Image();\n  image.onload = draw;\n  image.onerror = failed;\n  const canvasRef = useRef<HTMLCanvasElement>(null);\n\n  async function detect(): Promise<void> {\n    if (canvasRef.current) {\n      const detectedObjects = await props.cocoNet.detect(canvasRef.current!);\n      const ctx = canvasRef.current.getContext('2d')! as CanvasRenderingContext2D;\n      console.info('Detected Objects:');\n      console.info(detectedObjects);\n      drawRect(detectedObjects, ctx);\n    }\n  }\n\n  function draw() {\n    if (canvasRef.current) {\n      canvasRef.current.width = image.width + 100;\n      canvasRef.current.height = image.height + 100;\n      const ctx = canvasRef.current.getContext('2d')! as CanvasRenderingContext2D;\n      ctx.drawImage(image, 50, 50);\n    }\n    detect();\n  }\n\n  function failed() {\n    console.error(\"The provided file couldn't be loaded as an Image media\");\n  }\n\n  function handleImageUpload(event: React.ChangeEvent<HTMLInputElement>) {\n    image.src = URL.createObjectURL(event.currentTarget.files![0]);\n  }\n\n  return (\n    <>\n      <Divider orientation=\"left\">Detect Objects in Images</Divider>\n      <Row>\n        <Col span={24}>\n          <Input type=\"file\" onChange={handleImageUpload} />\n        </Col>\n      </Row>\n      <Row>\n        <Col span={24}>\n          <canvas ref={canvasRef}></canvas>\n        </Col>\n      </Row>\n    </>\n  );\n}\n\nImageUploader.displayName = 'ImageUploader';\nexport default ImageUploader;\n","import * as tf from '@tensorflow/tfjs';\nimport { Tensor } from '@tensorflow/tfjs';\nimport * as jsonClasses from '../assets/doddle-model/classes.json';\n\nexport interface DoddlePrediction {\n  class: string;\n  score: any;\n}\n\nexport class DoddleClassifier {\n  private model?: tf.LayersModel;\n  private classes?: string[];\n  constructor() {}\n\n  async loadModel() {\n    this.model = await tf.loadLayersModel('model.json');\n    this.classes = jsonClasses.classes;\n  }\n\n  getImageFromCanvas(canvasElement: HTMLCanvasElement): ImageData {\n    const ctx = canvasElement.getContext('2d')! as CanvasRenderingContext2D;\n\n    return ctx.getImageData(\n      0,\n      0,\n      canvasElement.width,\n      canvasElement.height\n    );\n  }\n\n  async detect(canvasElement: HTMLCanvasElement, topN: number): Promise<string | DoddlePrediction[]> {\n    // Predict using DoddleClassifier\n    const imgData = this.getImageFromCanvas(canvasElement);\n\n    tf.engine().startScope();\n\n    const tensor = tf.browser.fromPixels(imgData, 1);\n    const resized = tf.image\n      .resizeBilinear(tensor, [28, 28])\n      .reshape([28, 28, 1])\n      .toFloat();\n    const normalized = tf.scalar(1.0).sub(resized.div(tf.scalar(255.0)));\n\n    const batched = normalized.expandDims(0);\n\n    // tf.browser.toPixels(normalized as tf.Tensor3D, canvasElement!);\n\n    let prediction: string | DoddlePrediction[];\n\n    try {\n      if (topN === 1) {\n        prediction = await this.predict(batched);\n      } else {\n        prediction = await this.predictTopN(batched, topN);\n      }\n    } catch (e) {\n      throw e;\n    }\n\n    tf.engine().endScope();\n\n    return prediction;\n  }\n\n  async predict(data: tf.Tensor): Promise<string> {\n    if (this.model && this.classes) {\n      const argMax = await (this.model.predict(data) as Tensor)\n        .argMax(-1)\n        .data();\n      return this.classes[argMax[0]];\n    } else {\n      throw new Error('DoddleClassifier: Please load the model first before predicting.');\n    }\n  }\n\n  async predictTopN(data: tf.Tensor, n: number): Promise<DoddlePrediction[]> {\n    if (this.model && this.classes) {\n      const prediction = await (this.model.predict(data) as Tensor)\n        .data();\n      const topValues = Array.from(\n        [...prediction as any].sort((a, b) => b - a).slice(0, n)\n      );\n      return topValues.map((x) => ({\n        class: this.classes![prediction.indexOf(x)],\n        score: x,\n      }));\n    } else {\n      throw new Error('DoddleClassifier: Please load the model first before predicting top N.');\n    }\n  }\n}\n","export const SKETCH_DEFAULT_EXPORT_FORMAT = 'png';\nexport const SKETCH_DEFAULT_EXPORT_FILENAME = `sketch.${SKETCH_DEFAULT_EXPORT_FORMAT}`;\n\nexport const SKETCH_DEFAULT_STROKE_COLOR = 'white';\nexport const SKETCH_DEFAULT_CANVAS_COLOR = 'black';\n\nexport const SKETCH_MIN_STROKE_WIDTH = 0;\nexport const SKETCH_MAX_STROKE_WIDTH = 100;\nexport const SKETCH_DEFAULT_STROKE_WIDTH = 10;\n\nexport const SKETCH_MIN_ERASE_WIDTH = 0;\nexport const SKETCH_MAX_ERASE_WIDTH = 100;\nexport const SKETCH_DEFAULT_ERASE_WIDTH = 10;\n","import { useState } from \"react\";\nimport { Button, InputNumber, Tooltip } from \"antd\";\nimport { DownloadOutlined, UndoOutlined, RedoOutlined, EditOutlined, ClearOutlined, DeleteOutlined, ReloadOutlined } from '@ant-design/icons';\nimport { ReactSketchCanvas } from \"react-sketch-canvas\";\nimport { ButtonType } from \"antd/lib/button\";\nimport { SketchPicker } from 'react-color';\nimport { SKETCH_DEFAULT_EXPORT_FORMAT, SKETCH_DEFAULT_EXPORT_FILENAME, SKETCH_MIN_STROKE_WIDTH, SKETCH_MAX_STROKE_WIDTH, SKETCH_DEFAULT_STROKE_WIDTH, SKETCH_MIN_ERASE_WIDTH, SKETCH_MAX_ERASE_WIDTH, SKETCH_DEFAULT_ERASE_WIDTH, SKETCH_DEFAULT_CANVAS_COLOR } from \"./constants\";\n\ninterface SketchActionButton {\n  buttonType: ButtonType;\n  text: string;\n  icon: React.ReactNode;\n  isDanger?: boolean;\n  style?: React.CSSProperties;\n  onClick: () => void | Promise<void>,\n}\n\ninterface ImageDrawerToolsProps {\n  sketchRef: ReactSketchCanvas;\n  strokeColor: string;\n  setStrokeColor: React.Dispatch<React.SetStateAction<string>>;\n  setStrokeWidth: React.Dispatch<React.SetStateAction<number>>;\n  setEraseWidth: React.Dispatch<React.SetStateAction<number>>;\n}\n\nfunction ImageDrawerTools(props: ImageDrawerToolsProps): JSX.Element {\n  const [isPenMode, setIsPenMode] = useState<boolean>(true);\n\n  function undo(): void {\n    props.sketchRef.undo();\n  }\n\n  function redo(): void {\n    props.sketchRef.redo();\n  }\n\n  function toEraserMode(): void {\n    props.sketchRef.eraseMode(true);\n    setIsPenMode(false);\n  }\n\n  function toPenMode(): void {\n    props.sketchRef.eraseMode(false);\n    setIsPenMode(true);\n  }\n\n  function clear(): void {\n    props.sketchRef.clearCanvas();\n  }\n\n  function reset(): void {\n    props.sketchRef.resetCanvas();\n  }\n\n  async function downloadSketch(): Promise<void> {\n    try {\n      const data = await props.sketchRef.exportImage(SKETCH_DEFAULT_EXPORT_FORMAT);\n      const element = document.createElement('a');\n      element.setAttribute('href', data);\n      element.setAttribute('download', SKETCH_DEFAULT_EXPORT_FILENAME);\n  \n      element.style.display = 'none';\n      document.body.appendChild(element);\n  \n      element.click();\n  \n      document.body.removeChild(element);\n    } catch (error) {\n      console.error(error);\n    }\n  }\n\n  const actions: SketchActionButton[] = [\n    {\n      buttonType: \"primary\",\n      text: 'Undo',\n      icon: <UndoOutlined />,\n      onClick: undo,\n    },\n    {\n      buttonType: \"primary\",\n      text: 'Redo',\n      icon: <RedoOutlined />,\n      onClick: redo,\n    },\n    {\n      buttonType: \"dashed\",\n      text: 'Pen Mode',\n      icon: <EditOutlined />,\n      onClick: toPenMode,\n    },\n    {\n      buttonType: \"dashed\",\n      text: 'Eraser Mode',\n      icon: <ClearOutlined />,\n      onClick: toEraserMode,\n    },\n    {\n      buttonType: \"primary\",\n      text: 'Clear',\n      icon: <ReloadOutlined />,\n      isDanger: true,\n      onClick: clear,\n    },\n    {\n      buttonType: \"primary\",\n      text: 'Reset',\n      icon: <DeleteOutlined />,\n      isDanger: true,\n      onClick: reset,\n    },\n    {\n      buttonType: \"primary\",\n      text: 'Download',\n      icon: <DownloadOutlined />,\n      onClick: downloadSketch,\n      style: {\n        backgroundColor: 'green',\n        borderColor: 'green',\n      }\n    }\n  ];\n\n  return (\n    <>\n      {actions.map((action, index) => (\n        <Button\n          key={index}\n          type={action.buttonType}\n          icon={action.icon}\n          onClick={action.onClick}\n          style={{\n            width: '100%',\n            display: \"block\",\n            marginBottom: \"1em\",\n            ...action.style,\n          }}\n          danger={action.isDanger}\n        >\n          {action.text}\n        </Button>\n      ))}\n      <Tooltip title={<SketchPicker color={props.strokeColor} onChangeComplete={(color) => props.setStrokeColor(color.hex)} />}>\n        <Button\n          // icon={<BgColorsOutlined style={{ color: props.strokeColor }} />}\n          type=\"dashed\"\n          style={{\n            width: '100%',\n            display: \"block\",\n            marginBottom: \"1em\",\n          }}\n        >\n          <span style={{\n            backgroundColor: props.strokeColor,\n            borderColor: SKETCH_DEFAULT_CANVAS_COLOR,\n            borderWidth: \"2px\",\n            borderRadius: \"0.5em\",\n            width: \"1em\",\n            height: \"1em\",\n            marginRight: \"0.5em\",\n            verticalAlign: \"middle\",\n          }} />\n          Stroke Color\n        </Button>\n      </Tooltip>\n      <div style={{ marginBottom: \"1em\" }}>\n        <label htmlFor=\"stroke-width\">Stroke Width:</label>\n        <InputNumber\n          id=\"stroke-width\"\n          name=\"stroke-width\"\n          min={SKETCH_MIN_STROKE_WIDTH}\n          max={SKETCH_MAX_STROKE_WIDTH}\n          defaultValue={SKETCH_DEFAULT_STROKE_WIDTH}\n          onChange={(newStrokeWidth) => props.setStrokeWidth(newStrokeWidth)}\n          disabled={!isPenMode}\n          style={{ width: \"100%\" }}\n        />\n      </div>\n      <div style={{ marginBottom: \"1em\" }}>\n        <label htmlFor=\"erase-width\">Erase Width:</label>\n        <InputNumber\n          id=\"erase-width\"\n          name=\"erase-width\"\n          min={SKETCH_MIN_ERASE_WIDTH}\n          max={SKETCH_MAX_ERASE_WIDTH}\n          defaultValue={SKETCH_DEFAULT_ERASE_WIDTH}\n          onChange={(newEraseWidth) => props.setEraseWidth(newEraseWidth)}\n          disabled={isPenMode}\n          style={{ width: \"100%\" }}\n        />\n      </div>\n    </>\n  );\n}\n\nImageDrawerTools.displayName = 'ImageDrawerTools';\nexport default ImageDrawerTools;\n","import { useState } from \"react\";\nimport { Row, Col } from \"antd\";\nimport { ReactSketchCanvas } from \"react-sketch-canvas\";\n\nimport ImageDrawerTools from \"./ImageDrawerTools\";\nimport { SKETCH_DEFAULT_STROKE_COLOR, SKETCH_DEFAULT_STROKE_WIDTH, SKETCH_DEFAULT_ERASE_WIDTH, SKETCH_DEFAULT_CANVAS_COLOR } from \"./constants\";\n\ninterface ImageDrawerProps {\n  setSketchCanvas: React.Dispatch<React.SetStateAction<ReactSketchCanvas | undefined>>;\n}\n\nfunction ImageDrawer(props: ImageDrawerProps): JSX.Element {\n  const [sketchCanvas, setSketchCanvas] = useState<ReactSketchCanvas>();\n  const [strokeColor, setStrokeColor] = useState<string>(SKETCH_DEFAULT_STROKE_COLOR);\n  const [strokeWidth, setStrokeWidth] = useState<number>(SKETCH_DEFAULT_STROKE_WIDTH);\n  const [eraseWidth, setEraseWidth] = useState<number>(SKETCH_DEFAULT_ERASE_WIDTH);\n\n  const onSketchCanvasRefChange = (node: ReactSketchCanvas) => {\n    setSketchCanvas(node);\n    props.setSketchCanvas(node);\n  };\n\n  return (\n    <>\n      <Row gutter={8}>\n        <Col span={20}>\n          <ReactSketchCanvas\n            ref={onSketchCanvasRefChange}\n            style={{\n              border: \"0.0625rem solid #9c9c9c\",\n              borderRadius: \"0.25rem\",\n            }}\n            width=\"100%\"\n            height=\"400px\"\n            strokeWidth={strokeWidth}\n            eraserWidth={eraseWidth}\n            strokeColor={strokeColor}\n            canvasColor={SKETCH_DEFAULT_CANVAS_COLOR}\n          />\n        </Col>\n        <Col span={4}>\n          {sketchCanvas && (\n            <ImageDrawerTools\n              sketchRef={sketchCanvas}\n              strokeColor={strokeColor}\n              setStrokeColor={setStrokeColor}\n              setEraseWidth={setEraseWidth}\n              setStrokeWidth={setStrokeWidth}\n            />\n          )}\n        </Col>\n      </Row>\n    </>\n  );\n}\n\nImageDrawer.displayName = 'ImageDrawer';\nexport default ImageDrawer;\n","import { useState } from \"react\";\nimport { Row, Col, Button, Select, InputNumber, List, Typography, Divider } from \"antd\";\nimport { ObjectDetection } from \"@tensorflow-models/coco-ssd\";\nimport { ReactSketchCanvas } from \"react-sketch-canvas\";\n\nimport { SKETCH_DEFAULT_EXPORT_FORMAT } from \"./constants\";\nimport { drawRect } from \"../../utils/drawing\";\nimport { DoddleClassifier, DoddlePrediction } from \"../../models/DoddleClassifier.model\";\nimport ImageDrawer from \"./ImageDrawer\";\n\nconst { Option } = Select;\n\nconst MIN_TOP_N = 1;\nconst MAX_TOP_N = 20;\nconst DEFAULT_TOP_N = 5;\n\nconst SCORE_THRESHOLD = 0.65;\n\nenum OBJECT_DETECTION_MODEL {\n  coco = \"coco\",\n  quickDraw = \"quickDraw\",\n}\n\ninterface ObjectDetectionPrediction {\n  class: string;\n  score: number;\n}\n\ninterface ImageDrawerProps {\n  cocoNet: ObjectDetection;\n  doddleClassifier: DoddleClassifier;\n}\n\nfunction ImageDrawerDetector(props: ImageDrawerProps): JSX.Element {\n  const [sketchCanvas, setSketchCanvas] = useState<ReactSketchCanvas>();\n  const [model, setModel] = useState<OBJECT_DETECTION_MODEL>(OBJECT_DETECTION_MODEL.coco);\n  const [topN, setTopN] = useState<number>(DEFAULT_TOP_N);\n  const [objectDetectionPredictions, setObjectDetectionPredictions] = useState<ObjectDetectionPrediction[]>([]);\n\n  const image = new Image();\n  image.onload = onNewImage;\n  image.onerror = failed;\n  const [detectionCanvas, setDetectionCanvas] = useState<HTMLCanvasElement>();\n\n  const onDetectionCanvasRefChange = (node: HTMLCanvasElement) => setDetectionCanvas(node);\n\n  async function detectCoco(): Promise<void> {\n    console.info('Detecting objects in canvas with COCO...');\n    if (detectionCanvas) {\n      const detectedObjects = await props.cocoNet.detect(detectionCanvas);\n      const ctx = detectionCanvas.getContext('2d')! as CanvasRenderingContext2D;\n      console.info('Detected Objects:');\n      console.info(detectedObjects);\n\n      setObjectDetectionPredictions(detectedObjects);\n\n      // Draw bounding boxes\n      drawRect(detectedObjects, ctx);\n    }\n  }\n\n  async function detectQuickDraw(): Promise<void> {\n    console.info('Detecting objects in canvas with QuickDraw...');\n    if (detectionCanvas) {\n      let result = await props.doddleClassifier.detect(detectionCanvas, topN!);\n      console.info('Detected Objects:');\n      console.info(result);\n      \n      if (topN === 1) {\n        result = result as string;\n        setObjectDetectionPredictions([\n          { class: result, score: 10 }\n        ]);\n      } else {\n        result = result as DoddlePrediction[];\n        setObjectDetectionPredictions(result);\n      }\n    }\n  }\n\n  async function onNewImage(): Promise<void> {\n    if (detectionCanvas) {\n      detectionCanvas.width = image.width + 200;\n      detectionCanvas.height = image.height + 200;\n      const ctx = detectionCanvas.getContext('2d')! as CanvasRenderingContext2D;\n      ctx.drawImage(image, 100, 100);\n\n      console.info(`Starting Object detection...`);\n      if (model === OBJECT_DETECTION_MODEL.coco) await detectCoco();\n      if (model === OBJECT_DETECTION_MODEL.quickDraw) await detectQuickDraw();\n    }\n  }\n\n  function failed() {\n    console.error(\"The provided file couldn't be loaded as an Image media\");\n  }\n\n  async function startDetection(): Promise<void> {\n    if (sketchCanvas) {\n      const data = await sketchCanvas.exportImage(SKETCH_DEFAULT_EXPORT_FORMAT);\n      image.src = data;\n    }\n  }\n\n  return (\n    <>\n      <Divider orientation=\"left\">Detect Objects in Drawings</Divider>\n      <Row gutter={8}>\n        <Col span={24}>\n          <ImageDrawer setSketchCanvas={setSketchCanvas} />\n        </Col>\n      </Row>\n      <Row gutter={8}>\n        <Col span={6}>\n          <Select defaultValue={model} onChange={(value) => setModel(value as any as OBJECT_DETECTION_MODEL)}>\n            {Object.keys(OBJECT_DETECTION_MODEL).map(key => (\n              <Option key={key} value={key}>\n                {key}                \n              </Option>\n            ))}\n          </Select>\n        </Col>\n        <Col span={6}>\n          <InputNumber\n            id=\"erase-width\"\n            name=\"erase-width\"\n            min={MIN_TOP_N}\n            max={MAX_TOP_N}\n            defaultValue={DEFAULT_TOP_N}\n            onChange={(value) => setTopN(value)}\n            disabled={model === OBJECT_DETECTION_MODEL.coco}\n            style={{ width: \"100%\" }}\n          />\n        </Col>\n        <Col span={12}>\n          <Button type=\"primary\" onClick={startDetection} disabled={!detectionCanvas}>Run Object Detection</Button>\n        </Col>\n      </Row>\n      <Row>\n        <Col span={24}>\n          <Divider orientation=\"left\">Detected Objects</Divider>\n          <List\n            bordered\n            dataSource={objectDetectionPredictions}\n            locale={{\n              emptyText: 'No Objects Detected'\n            }}\n            renderItem={item => (\n              <List.Item>\n                <Typography.Text strong type={item.score >=  SCORE_THRESHOLD ? \"success\" : \"secondary\"}>{item.class}</Typography.Text> {item.score}\n              </List.Item>\n            )}\n          />\n        </Col>\n      </Row>\n      <Row>\n        <Col span={24}>\n          <canvas ref={onDetectionCanvasRefChange}></canvas>\n        </Col>\n      </Row>\n    </>\n  );\n}\n\nImageDrawerDetector.displayName = 'ImageDrawerDetector';\nexport default ImageDrawerDetector;\n","import { useState, useEffect } from \"react\";\nimport { Row, Col, PageHeader, Spin } from \"antd\";\nimport * as tf from \"@tensorflow/tfjs\";\nimport * as cocossd from \"@tensorflow-models/coco-ssd\";\nimport * as b from '@tensorflow/tfjs-backend-cpu';\nimport * as webgl from '@tensorflow/tfjs-backend-webgl';\n\nimport './App.scss';\nimport ImageUploader from './components/image-uploader/ImageUploader';\nimport { DoddleClassifier } from \"./models/DoddleClassifier.model\";\nimport ImageDrawerDetector from \"./components/image-drawer/ImageDrawerDetector\";\nimport LoadingOutlined from \"@ant-design/icons/lib/icons/LoadingOutlined\";\n\nfunction App() {\n  const [doddleClassifier, setDoddleClassifier] = useState<DoddleClassifier>();\n  const [cocoNet, setCocoNet] = useState<cocossd.ObjectDetection>();\n\n  useEffect(() => {\n    loadCoco();\n    loadDoddleClassifier();\n  }, []);\n\n  async function loadDoddleClassifier(): Promise<void> {\n    const model = new DoddleClassifier();\n    await model.loadModel();\n    setDoddleClassifier(model);\n    console.log(\"Doddle Classifier loaded.\");\n  }\n\n  async function loadCoco(): Promise<void> {\n    tf.getBackend()\n    setCocoNet(await cocossd.load());\n    console.log(\"Handpose model loaded.\");\n  };\n\n  return (\n    <>\n      <Row>\n        <Col span={24}>\n          <PageHeader\n            title=\"Image Processing\"\n            subTitle=\"You can draw or upload images here.\"\n          />\n          {(!cocoNet || !doddleClassifier) && (\n            <Spin\n              size=\"large\"\n              tip=\"Loading Object Detection Models...\"\n              indicator={<LoadingOutlined style={{ fontSize: 48 }} spin />}\n              style={{\n                display: \"block\",\n                position: \"fixed\",\n                zIndex: 1031,\n                top: \"50%\",\n                right: \"50%\",\n                marginTop: \"-..px\",\n                marginRight: \"-..px\",\n              }}\n            />\n          )}\n          {cocoNet && doddleClassifier && (\n            <Row gutter={10}>\n              <Col span={12} style={{ paddingLeft: '3em' }}>\n                <ImageDrawerDetector cocoNet={cocoNet} doddleClassifier={doddleClassifier} />\n              </Col>\n              <Col span={12} style={{ paddingRight: '3em' }}>\n                <ImageUploader cocoNet={cocoNet} />\n              </Col>\n            </Row>\n          )}\n        </Col>\n      </Row>\n    </>\n  );\n}\n\nexport default App;\n","import { ReportHandler } from 'web-vitals';\n\nconst reportWebVitals = (onPerfEntry?: ReportHandler) => {\n  if (onPerfEntry && onPerfEntry instanceof Function) {\n    import('web-vitals').then(({ getCLS, getFID, getFCP, getLCP, getTTFB }) => {\n      getCLS(onPerfEntry);\n      getFID(onPerfEntry);\n      getFCP(onPerfEntry);\n      getLCP(onPerfEntry);\n      getTTFB(onPerfEntry);\n    });\n  }\n};\n\nexport default reportWebVitals;\n","import React from 'react';\nimport ReactDOM from 'react-dom';\nimport './index.css';\nimport App from './App';\nimport reportWebVitals from './reportWebVitals';\n\nReactDOM.render(\n  <React.StrictMode>\n    <App />\n  </React.StrictMode>,\n  document.getElementById('root')\n);\n\n// If you want to start measuring performance in your app, pass a function\n// to log results (for example: reportWebVitals(console.log))\n// or send to an analytics endpoint. Learn more: https://bit.ly/CRA-vitals\nreportWebVitals();\n"],"sourceRoot":""}